<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GTFO-API</name>
    </assembly>
    <members>
        <member name="P:GTFO.API.AssetAPI.Status">
            <summary>
            Status info for the <see cref="T:GTFO.API.AssetAPI"/>
            </summary>
        </member>
        <member name="E:GTFO.API.AssetAPI.OnStartupAssetsLoaded">
            <summary>
            Invoked when the game's startup assets have been fully loaded
            </summary>
        </member>
        <member name="E:GTFO.API.AssetAPI.OnAssetBundlesLoaded">
            <summary>
            Invoked when all external asset bundles have been loaded (Not invoked if no bundles)
            </summary>
        </member>
        <member name="E:GTFO.API.AssetAPI.OnImplReady">
            <summary>
            Invoked when the internal handler is ready
            </summary>
        </member>
        <member name="M:GTFO.API.AssetAPI.ContainsAsset(System.String)">
            <summary>
            Checks if an asset is already registered in the <see cref="T:GTFO.API.AssetAPI"/>
            </summary>
            <param name="assetName">Name of the asset to check</param>
            <returns>Whether the asset is registered or not</returns>
        </member>
        <member name="M:GTFO.API.AssetAPI.GetLoadedAsset(System.String)">
            <summary>
            Obtains an asset from the currently loaded asset shards
            </summary>
            <param name="path">The path to the asset to use</param>
            <returns>The <see cref="T:UnityEngine.Object"/> of the asset requested or null if it's not loaded</returns>
        </member>
        <member name="M:GTFO.API.AssetAPI.GetLoadedAsset``1(System.String)">
            <summary>
            Obtains an asset from the currently loaded asset shards and casts it to <typeparamref name="TAsset"/>
            </summary>
            <typeparam name="TAsset">The type of asset to load</typeparam>
            <param name="path">The path to the asset to use</param>
            <returns><typeparamref name="TAsset"/> as the asset requested or null if it's not loaded</returns>
            <exception cref="T:System.InvalidCastException">The loaded asset cannot be cast to <typeparamref name="TAsset"/></exception>
        </member>
        <member name="M:GTFO.API.AssetAPI.RegisterAsset(System.String,UnityEngine.Object)">
            <summary>
            Registers an asset into the asset shard lookup
            </summary>
            <param name="name">The name/path of the asset to use as a lookup</param>
            <param name="gameObject">The <see cref="T:UnityEngine.Object"/> that will be used</param>
            <exception cref="T:System.ArgumentException">The name is already registered</exception>
        </member>
        <member name="M:GTFO.API.AssetAPI.RegisterAssetBundle(UnityEngine.AssetBundle)">
            <summary>
            Registers an <see cref="T:UnityEngine.AssetBundle"/>'s assets into the asset registry
            <para>Use <seealso cref="M:GTFO.API.AssetAPI.LoadAndRegisterAssetBundle(System.String)"/> if you want to load from a path</para>
            </summary>
            <param name="bundle">The bundle to register</param>
        </member>
        <member name="M:GTFO.API.AssetAPI.LoadAndRegisterAssetBundle(System.String)">
            <summary>
            Loads an asset bundle by path and registers its assets into the asset registry
            </summary>
            <param name="pathToBundle">The location of the asset bundle</param>
            <exception cref="T:System.Exception">Failed to load the bundle</exception>
        </member>
        <member name="M:GTFO.API.AssetAPI.LoadAndRegisterAssetBundle(System.Byte[])">
            <summary>
            Loads an asset bundle from bytes and registers its assets into the asset registry
            </summary>
            <param name="bundleBytes">The raw bytes of the asset bundle</param>
            <exception cref="T:System.Exception">Failed to load the bundle</exception>
        </member>
        <member name="M:GTFO.API.AssetAPI.InstantiateAsset(System.String,System.String)">
            <summary>
            Clones an asset into a new one with a different name
            </summary>
            <param name="assetName">The original asset name</param>
            <param name="copyName">The name it should be cloned into</param>
            <returns>The <see cref="T:UnityEngine.Object"/> of the asset requested or null if it's not loaded</returns>
            <exception cref="T:System.ArgumentException">The name you're trying to copy into is already registered</exception>
        </member>
        <member name="M:GTFO.API.AssetAPI.InstantiateAsset``1(System.String,System.String)">
            <summary>
            Clones an asset into a new one with a different name
            </summary>
            <typeparam name="TAsset">Type of asset to extract</typeparam>
            <param name="assetName">The original asset name</param>
            <param name="copyName">The name it should be cloned into</param>
            <returns>The asset requested as <typeparamref name="TAsset"/> or null if it's not loaded</returns>
            <exception cref="T:System.ArgumentException">The name you're trying to copy into is already registered</exception>
            <exception cref="T:System.InvalidCastException">The asset cannot be cast to <typeparamref name="TAsset"/></exception>
        </member>
        <member name="M:GTFO.API.AssetAPI.TryInstantiateAsset``1(System.String,System.String,``0@)">
            <summary>
            Attempts to clone an asset into a new one with a different name
            </summary>
            <typeparam name="TAsset">Type of asset to extract</typeparam>
            <param name="assetName">The original asset name</param>
            <param name="copyName">The name it should be cloned into</param>
            <param name="clonedObj"></param>
            <returns>If the asset was successfully copied and cast to <typeparamref name="TAsset"/></returns>
            <exception cref="T:System.ArgumentException">The name you're trying to copy into is already registered</exception>
        </member>
        <member name="P:GTFO.API.GameDataAPI.Status">
            <summary>
            Status info for the <see cref="T:GTFO.API.GameDataAPI"/>
            </summary>
        </member>
        <member name="E:GTFO.API.GameDataAPI.OnGameDataInitialized">
            <summary>
            Invoked when the game data has been fully initialized
            </summary>
        </member>
        <member name="P:GTFO.API.Il2CppAPI.Status">
            <summary>
            Status info for the <see cref="T:GTFO.API.Il2CppAPI"/>
            </summary>
        </member>
        <member name="M:GTFO.API.Il2CppAPI.InjectWithInterface``1">
            <summary>
            Injects a class and its interfaces with <see cref="T:Il2CppInterop.Runtime.Injection.ClassInjector"/>
            </summary>
            <typeparam name="T">The class to inject into Il2Cpp</typeparam>
        </member>
        <member name="M:GTFO.API.Il2CppAPI.GetIl2CppMethod``1(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Obtains the function pointer for an Il2Cpp internal method
            </summary>
            <typeparam name="T">The type to look for the method in</typeparam>
            <param name="methodName">Method name in <typeparamref name="T"/></param>
            <param name="isGeneric">If the requested method is generic</param>
            <param name="returnTypeName">Full return type name e.g (System.Void)</param>
            <param name="argTypes">List of full type names for the arguments e.g (System.Single)</param>
            <returns>Function pointer of the Il2Cpp method or 0x00 if not found</returns>
        </member>
        <member name="M:GTFO.API.Il2CppAPI.GetIl2CppMethod``2(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Obtains a delegate for an Il2Cpp internal method
            </summary>
            <typeparam name="T">The type to look for the method in</typeparam>
            <typeparam name="TDelegate">The delegate to return</typeparam>
            <param name="methodName">Method name in <typeparamref name="T"/></param>
            <param name="isGeneric">If the requested method is generic</param>
            <param name="returnTypeName">Full return type name e.g (System.Void)</param>
            <param name="argTypes">List of full type names for the arguments e.g (System.Single)</param>
            <returns>A delegate to invoke the Il2Cpp method or null if invalid</returns>
        </member>
        <member name="M:GTFO.API.Il2CppAPI.CreateGenericDetour``2(System.String,System.String,System.String[],System.Type[],``1,``1@)">
            <summary>
            Creates (and applies) a detour to a generic il2cpp method
            </summary>
            <typeparam name="TClass">Il2Cpp class that contains the generic method</typeparam>
            <typeparam name="TDelegate">Delegate of the method</typeparam>
            <param name="methodName">Name of the il2cpp method</param>
            <param name="returnType">Return type of the il2cpp method</param>
            <param name="paramTypes">List of full type names for the arguments</param>
            <param name="genericArguments">List of generic arguments for the il2cpp class</param>
            <param name="to">The method to detour to</param>
            <param name="original">Delegate to the original function</param>
            <returns>The applied detour</returns>
            <exception cref="T:System.ArgumentException">The il2cpp class is not registered in il2cpp</exception>
        </member>
        <member name="P:GTFO.API.NetworkAPI.Status">
            <summary>
            Status info for the <see cref="T:GTFO.API.NetworkAPI"/>
            </summary>
        </member>
        <member name="M:GTFO.API.NetworkAPI.IsEventRegistered(System.String)">
            <summary>
            Checks if an event is registered in the <see cref="T:GTFO.API.NetworkAPI"/>
            </summary>
            <param name="eventName">The name of the event to check.</param>
            <returns>If the specified event name is in use</returns>
        </member>
        <member name="M:GTFO.API.NetworkAPI.RegisterEvent``1(System.String,System.Action{System.UInt64,``0})">
            <summary>
            Registers a network event with a name and receive action.
            </summary>
            <typeparam name="T">The struct that will be used for the event info</typeparam>
            <param name="eventName">The name of the event to register</param>
            <param name="onReceive">The method that will be invoked when the event is received from another player</param>
            <exception cref="T:System.ArgumentException">The event is already registered</exception>
        </member>
        <member name="M:GTFO.API.NetworkAPI.InvokeEvent``1(System.String,``0,SNetwork.SNet_ChannelType)">
            <summary>
            Sends an event to every player connected to the lobby
            </summary>
            <typeparam name="T">The struct that holds the event information</typeparam>
            <param name="eventName">The name of the event to invoke</param>
            <param name="payload">The data to send</param>
            <param name="channelType">The <see cref="T:SNetwork.SNet_ChannelType"/> to send the event to</param>
        </member>
        <member name="M:GTFO.API.NetworkAPI.InvokeEvent``1(System.String,``0,SNetwork.SNet_Player,SNetwork.SNet_ChannelType)">
            <summary>
            Sends an event to a specific player in the lobby
            </summary>
            <typeparam name="T">The struct that holds the event information</typeparam>
            <param name="eventName">The name of the event to invoke</param>
            <param name="payload">The data to send</param>
            <param name="target">The player to send the event to</param>
            <param name="channelType">The <see cref="T:SNetwork.SNet_ChannelType"/> to send the event to</param>
        </member>
        <member name="M:GTFO.API.NetworkAPI.InvokeEvent``1(System.String,``0,System.Collections.Generic.List{SNetwork.SNet_Player},SNetwork.SNet_ChannelType)">
            <summary>
            Sends an event to a specific set of players in the lobby
            </summary>
            <typeparam name="T">The struct that holds the event information</typeparam>
            <param name="eventName">The name of the event to invoke</param>
            <param name="payload">The data to send</param>
            <param name="targets">The players to send the event to</param>
            <param name="channelType">The <see cref="T:SNetwork.SNet_ChannelType"/> to send the event to</param>
        </member>
        <member name="P:GTFO.API.PrefabAPI.Status">
            <summary>
            Status info for the <see cref="T:GTFO.API.PrefabAPI"/>
            </summary>
        </member>
        <member name="M:GTFO.API.PrefabAPI.CreateConsumable(System.String,System.Boolean)">
            <summary>
            Creates a consumable from the provided asset and applies the necessary shaders and components
            </summary>
            <param name="assetName">The asset to create a consumable from</param>
            <param name="enableEmissive">If the consumable GFX should be emissive</param>
            <exception cref="T:System.ArgumentException">The asset isn't loaded</exception>
        </member>
        <member name="M:GTFO.API.PrefabAPI.CreateConsumablePickup(System.String,System.Boolean)">
            <summary>
            Creates a consumable pickup and applies the necessary shaders and components
            </summary>
            <param name="assetName">The asset to create a consumable pickup from</param>
            <param name="enableEmissive">If the consumable pickup GFX should be emissive</param>
            <exception cref="T:System.ArgumentException">The asset isn't loaded</exception>
            <exception cref="T:System.Exception">The asset doesn't contain a box collider for interaction</exception>
        </member>
        <member name="M:GTFO.API.PrefabAPI.CreateConsumableInstance``1(System.String)">
            <summary>
            Creates a consumble instance and applies the necessary shaders and components
            </summary>
            <typeparam name="T">A <see cref="T:GTFO.API.Components.ConsumableInstance"/> script to be attached to the asset for customized behavior</typeparam>
            <param name="assetName">The asset to create a consumable instance from</param>
            <exception cref="T:System.ArgumentException">The asset isn't loaded</exception>
            <exception cref="T:System.Exception">The asset doesn't contain a rigidbody</exception>
        </member>
        <member name="M:GTFO.API.PrefabAPI.CreateGearComponent(System.String,System.Boolean)">
            <summary>
            Creates a gear component and applies necessary shaders and components
            </summary>
            <param name="assetName">The asset to create a gear component from</param>
            <param name="enableEmissive">If the gear component GFX should be emissive</param>
            <exception cref="T:System.ArgumentException">The asset isn't loaded</exception>
        </member>
        <member name="M:GTFO.API.PrefabAPI.CreateSyringe(System.UInt32,System.Action{SyringeFirstPerson})">
            <summary>
            Attaches an OnUse action to a syringe by persistent id
            </summary>
            <param name="itemPersistentId">The persistent ID of the syringe from the <see cref="T:GameData.ItemDataBlock"/></param>
            <param name="onUse">The delegate that will be called when the syringe is used</param>
            <exception cref="T:System.ArgumentException">This persistent ID already has a registered use action</exception>
        </member>
        <member name="T:GTFO.API.Components.ConsumableInstance">
            <summary>
            The core class that is used for consumable instances
            </summary>
        </member>
        <member name="T:GTFO.API.Extensions.ListExtensions">
            <summary>
            Container for all extension for <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
        </member>
        <member name="M:GTFO.API.Extensions.ListExtensions.ToIl2Cpp``1(System.Collections.Generic.List{``0})">
            <summary>
            Converts the <see cref="T:System.Collections.Generic.List`1"/> to <see cref="T:Il2CppSystem.Collections.Generic.List`1"/>
            </summary>
            <returns>A copy of the list as <see cref="T:Il2CppSystem.Collections.Generic.List`1"/></returns>
        </member>
        <member name="T:GTFO.API.JSON.JsonSerializer">
            <summary>
            Wrapper class for System Json serializer
            </summary>
        </member>
        <member name="P:GTFO.API.JSON.JsonSerializer.DefaultSerializerSettings">
            <summary>
            Obtains the serialization options used by PersistentData
            </summary>
            <returns>The serialization options used by PersistentData</returns>
        </member>
        <member name="M:GTFO.API.JSON.JsonSerializer.Serialize(System.Object,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Converts the object specified into a JSON string.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="options">Options to control serialization behavior.</param>
            <returns>A JSON string representation of the value.</returns>
        </member>
        <member name="M:GTFO.API.JSON.JsonSerializer.Deserialize``1(System.String,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Parses the JSON text into an instance type of <typeparamref name="T"/>
            </summary>
            <typeparam name="T">The target type of the JSON value.</typeparam>
            <param name="json">The JSON text to parse.</param>
            <param name="options">Options to control the behavior during parsing.</param>
            <returns><typeparamref name="T"/> with deserialized JSON data</returns>
        </member>
        <member name="T:GTFO.API.Resources.ApiStatusInfo">
            <summary>
            Container for API statuses
            </summary>
        </member>
        <member name="P:GTFO.API.Resources.ApiStatusInfo.Created">
            <summary>
            If the API handler script has been created
            </summary>
        </member>
        <member name="P:GTFO.API.Resources.ApiStatusInfo.Ready">
            <summary>
            If the API handler is ready to be used
            </summary>
        </member>
        <member name="T:GTFO.API.Resources.APIStatus">
            <summary>
            Contains all of the usable API status information
            </summary>
        </member>
        <member name="P:GTFO.API.Resources.APIStatus.Asset">
            <summary>
            Status info for the <see cref="T:GTFO.API.AssetAPI"/>
            </summary>
        </member>
        <member name="P:GTFO.API.Resources.APIStatus.GameData">
            <summary>
            Status info for the <see cref="T:GTFO.API.GameDataAPI"/>
            </summary>
        </member>
        <member name="P:GTFO.API.Resources.APIStatus.Il2Cpp">
            <summary>
            Status info for the <see cref="T:GTFO.API.Il2CppAPI"/>
            </summary>
        </member>
        <member name="P:GTFO.API.Resources.APIStatus.Network">
            <summary>
            Status info for the <see cref="T:GTFO.API.NetworkAPI"/>
            </summary>
        </member>
        <member name="P:GTFO.API.Resources.APIStatus.Prefab">
            <summary>
            Status info for the <see cref="T:GTFO.API.PrefabAPI"/>
            </summary>
        </member>
        <member name="T:GTFO.API.Utilities.CoroutineDispatcher">
            <summary>
            Utility class for dispatching Coroutine without making new monobehaviour
            </summary>
        </member>
        <member name="M:GTFO.API.Utilities.CoroutineDispatcher.StartCoroutine(System.Collections.IEnumerator)">
            <summary>
            Start Coroutine (persistent between sessions)
            </summary>
            <param name="routine">Coroutine to Run</param>
        </member>
        <member name="M:GTFO.API.Utilities.CoroutineDispatcher.StartInLevelCoroutine(System.Collections.IEnumerator)">
            <summary>
            Start InLevel Coroutine that will be stopped automatically when you stop playing level
            </summary>
            <param name="routine">Coroutine to Run</param>
        </member>
        <member name="T:GTFO.API.Utilities.LiveEditEventHandler">
            <summary>
            LiveEditEventHandler
            </summary>
            <param name="e">EventArgs</param>
        </member>
        <member name="T:GTFO.API.Utilities.LiveEditEventArgs">
            <summary>
            LiveEditEvent Arguments
            </summary>
        </member>
        <member name="P:GTFO.API.Utilities.LiveEditEventArgs.Type">
            <summary>
            Updated Event Type
            </summary>
        </member>
        <member name="P:GTFO.API.Utilities.LiveEditEventArgs.FullPath">
            <summary>
            Full Path to File which it Updated
            </summary>
        </member>
        <member name="P:GTFO.API.Utilities.LiveEditEventArgs.FileName">
            <summary>
            Filename which it Updated
            </summary>
        </member>
        <member name="T:GTFO.API.Utilities.LiveEditEventType">
            <summary>
            LiveEditEvent Type
            </summary>
        </member>
        <member name="F:GTFO.API.Utilities.LiveEditEventType.Created">
            <summary>
            File has created
            </summary>
        </member>
        <member name="F:GTFO.API.Utilities.LiveEditEventType.Deleted">
            <summary>
            File has deleted
            </summary>
        </member>
        <member name="F:GTFO.API.Utilities.LiveEditEventType.Renamed">
            <summary>
            File has renamed
            </summary>
        </member>
        <member name="F:GTFO.API.Utilities.LiveEditEventType.Changed">
            <summary>
            File has changed
            </summary>
        </member>
        <member name="T:GTFO.API.Utilities.LiveEdit">
            <summary>
            Utility class to make support of LiveEdit config file for plugins
            </summary>
        </member>
        <member name="M:GTFO.API.Utilities.LiveEdit.CreateListener(System.String,System.String,System.Boolean)">
            <summary>
            Create the LiveEdit Listener and Allocate
            </summary>
            <param name="path">Base Path to Track the change</param>
            <param name="filter">File filter to filter the files ie) *.json</param>
            <param name="includeSubDir">Include Sub-directories?</param>
        </member>
        <member name="M:GTFO.API.Utilities.LiveEdit.TryReadFileContent(System.String,System.Action{System.String})">
            <summary>
            Read File Content safely from file
            </summary>
            <param name="filepath">File path to Read all Content</param>
            <param name="onReaded">Callback when it readed all content</param>
        </member>
        <member name="T:GTFO.API.Utilities.LiveEditListener">
            <summary>
            
            </summary>
        </member>
        <member name="P:GTFO.API.Utilities.LiveEditListener.FileChangedEventCooldown">
            <summary>
            Cooldown for FileChangedEvent for filtering double call of FileChanged event
            </summary>
        </member>
        <member name="E:GTFO.API.Utilities.LiveEditListener.FileChanged">
            <summary>
            Event when File has Changed, Thread-safe
            </summary>
        </member>
        <member name="E:GTFO.API.Utilities.LiveEditListener.FileDeleted">
            <summary>
            Event when File has Deleted, Thread-safe
            </summary>
        </member>
        <member name="E:GTFO.API.Utilities.LiveEditListener.FileCreated">
            <summary>
            Event when File has Created, Thread-safe
            </summary>
        </member>
        <member name="E:GTFO.API.Utilities.LiveEditListener.FileRenamed">
            <summary>
            Event when File has Renamed, Thread-safe
            </summary>
        </member>
        <member name="M:GTFO.API.Utilities.LiveEditListener.Dispose">
            <summary>
            Dispose LiveEditListener
            </summary>
        </member>
        <member name="M:GTFO.API.Utilities.LiveEditListener.StopListen">
            <summary>
            Stop Listening LiveEdit
            </summary>
        </member>
        <member name="M:GTFO.API.Utilities.LiveEditListener.StartListen">
            <summary>
            Start Listening LiveEdit (Default On LiveEdit Allocated)
            </summary>
        </member>
        <member name="T:GTFO.API.Utilities.PersistentData`1">
            <summary>
            Utility class used to easily store configuration and data on disk in JSON format
            </summary>
            <typeparam name="T">The data type to store on disk</typeparam>
        </member>
        <member name="P:GTFO.API.Utilities.PersistentData`1.CurrentData">
            <summary>
            The current data instance, loaded automatically when first accessed
            </summary>
        </member>
        <member name="P:GTFO.API.Utilities.PersistentData`1.persistentPath">
            <summary>
            The default data path on disk
            </summary>
        </member>
        <member name="P:GTFO.API.Utilities.PersistentData`1.PersistentDataVersion">
            <summary>
            The version of the stored data
            </summary>
        </member>
        <member name="M:GTFO.API.Utilities.PersistentData`1.Load">
            <summary>
            Loads the stored data from the default path and creates default if it didn't exist
            </summary>
            <returns>The stored data or default if it didn't exist</returns>
        </member>
        <member name="M:GTFO.API.Utilities.PersistentData`1.Load(System.String)">
            <summary>
            Loads the stored data from the specified path and creates default if it didn't exist
            </summary>
            <param name="path">The path to load from</param>
            <returns>The stored data or default if it didn't exist</returns>
        </member>
        <member name="M:GTFO.API.Utilities.PersistentData`1.Save">
            <summary>
            Saves this data to the default path
            </summary>
        </member>
        <member name="M:GTFO.API.Utilities.PersistentData`1.Save(System.String)">
            <summary>
            Saves this data to the specified path
            </summary>
            <param name="path">The path to save to</param>
        </member>
        <member name="T:GTFO.API.Utilities.RegexUtils">
            <summary>
            Regex utilities class
            </summary>
        </member>
        <member name="M:GTFO.API.Utilities.RegexUtils.TryParseVectorString(System.String,System.Single[]@)">
            <summary>
            Tries to parse an array of floats from json
            </summary>
            <param name="input">Json input string</param>
            <param name="vectorArray">Resulting array of floats</param>
            <returns>Whether parse was successful</returns>
        </member>
        <member name="T:GTFO.API.Utilities.ThreadDispatcher">
            <summary>
            Utility class for dispatching threads on the Unity main thread
            </summary>
        </member>
        <member name="M:GTFO.API.Utilities.ThreadDispatcher.Dispatch(System.Action)">
            <summary>
            Queues an action up to be executed on the next frame
            </summary>
            <param name="action">Action to execute on unity's main thread</param>
        </member>
    </members>
</doc>
